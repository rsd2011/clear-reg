import org.gradle.api.plugins.JavaPluginExtension
import org.gradle.api.tasks.testing.logging.TestExceptionFormat
import org.gradle.testing.jacoco.plugins.JacocoPluginExtension
import org.gradle.testing.jacoco.tasks.JacocoReport
import org.gradle.testing.jacoco.tasks.JacocoCoverageVerification

// backend 이하 모든 모듈에 전역 적용
subprojects { subproject ->
    plugins.withType(JavaPlugin) {
        subproject.pluginManager.apply('jacoco')

        subproject.extensions.configure(JavaPluginExtension) { javaExt ->
            javaExt.toolchain {
                languageVersion = JavaLanguageVersion.of(21)
            }
            javaExt.withSourcesJar()
            javaExt.withJavadocJar()
        }

        subproject.extensions.configure(JacocoPluginExtension) { jacocoExt ->
            jacocoExt.toolVersion = '0.8.11'
        }

        tasks.withType(Test).configureEach {
            useJUnitPlatform()
            testLogging {
                events 'passed', 'skipped', 'failed'
                exceptionFormat = TestExceptionFormat.FULL
            }
            finalizedBy(tasks.named('jacocoTestReport'))
            // 커버리지 게이트(라인 90%, 브랜치 75%)가 항상 실행되도록 테스트 후 검증까지 연결
            finalizedBy(tasks.named('jacocoTestCoverageVerification'))
        }

        // 핵심 도메인/인프라 코드까지 커버리지에 포함하기 위해 최소한의 예외만 둔다.
        def jacocoExclusions = ['**/*Application*.class', '**/config/**', '**/dto/**']
        // 전역적으로 공통 적용할 exclude 집합 (report/verification 모두 동일하게 사용)
        def jacocoGlobalExcludes = (jacocoExclusions + [
                '**/generated/**',
                '**/SiemProperties.*',
                '**/AuditKafkaProperties.*'
        ]).unique()

        def mainSourceSet = subproject.extensions.getByType(JavaPluginExtension).sourceSets.named('main').get()

        tasks.named('jacocoTestReport').configure { JacocoReport report ->
            dependsOn tasks.named('test')
            reports {
                xml.required = true
                html.required = true
            }
            report.classDirectories.setFrom(
                    mainSourceSet.output.classesDirs.asFileTree.matching {
                        exclude jacocoGlobalExcludes
                    }
            )
        }

        tasks.withType(JacocoCoverageVerification).configureEach { JacocoCoverageVerification verification ->
            verification.dependsOn tasks.named('test')
            verification.classDirectories.setFrom(
                    mainSourceSet.output.classesDirs.asFileTree.matching {
                        exclude jacocoGlobalExcludes
                    }
            )

            verification.violationRules {
                // 전역 BUNDLE 기준
                rule {
                    element = 'BUNDLE'
                    limit { counter = 'LINE';   value = 'COVEREDRATIO'; minimum = 0.90 }
                    limit { counter = 'BRANCH'; value = 'COVEREDRATIO'; minimum = 0.75 }
                }
                // CLASS 기준 (DTO 등 최소 예외는 classDirectories에서 이미 제외)
                rule {
                    element = 'CLASS'
                    enabled = true
                    limit { counter = 'LINE'; value = 'COVEREDRATIO'; minimum = 0.80 }
                }
                // 핵심 패키지 브랜치 기준
                rule {
                    element = 'PACKAGE'
                    enabled = true
                    includes = ['com.example.service.*', 'com.example.domain.*']
                    excludes = ['com.example.common.jpa.*', 'com.example.server.cache.*']
                    limit { counter = 'BRANCH'; value = 'COVEREDRATIO'; minimum = 0.80 }
                }
            }
        }

        tasks.named('check').configure {
            dependsOn tasks.withType(JacocoCoverageVerification)
        }
    }
}
